[
  {
    "name": "lib/format",
    "type": "registry:lib",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/format.ts",
        "content": "import { DATE_FORMATS, type DateFormat } from '../constants/date-formats';\n\n/**\n * Format currency amount\n * @example formatCurrency(1000000, 'vi-VN', 'VND') // '1.000.000 â‚«'\n */\nexport function formatCurrency(\n  amount: number,\n  locale: string = 'en-US',\n  currency: string = 'USD',\n): string {\n  return new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency,\n  }).format(amount);\n}\n\n/**\n * Format date using date-fns format or custom format\n * @example formatDate(new Date(), 'short') // '01/01/2024'\n */\nexport function formatDate(\n  date: Date | string | number,\n  format: DateFormat | string = 'short',\n): string {\n  const dateObj = typeof date === 'string' || typeof date === 'number' ? new Date(date) : date;\n\n  if (isNaN(dateObj.getTime())) {\n    return '';\n  }\n\n  // If format is a key in DATE_FORMATS, use it\n  if (format in DATE_FORMATS) {\n    const formatStr = DATE_FORMATS[format as DateFormat];\n    // Simple date formatting without date-fns dependency\n    return formatDateString(dateObj, formatStr);\n  }\n\n  // Otherwise use as custom format string\n  return formatDateString(dateObj, format);\n}\n\nfunction formatDateString(date: Date, format: string): string {\n  const day = date.getDate().toString().padStart(2, '0');\n  const month = (date.getMonth() + 1).toString().padStart(2, '0');\n  const year = date.getFullYear();\n  const hours = date.getHours().toString().padStart(2, '0');\n  const minutes = date.getMinutes().toString().padStart(2, '0');\n  const seconds = date.getSeconds().toString().padStart(2, '0');\n\n  const monthNames = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December',\n  ];\n\n  return format\n    .replace(/dd/g, day)\n    .replace(/MM/g, month)\n    .replace(/yyyy/g, year.toString())\n    .replace(/MMMM/g, monthNames[date.getMonth()])\n    .replace(/MMM/g, monthNames[date.getMonth()].substring(0, 3))\n    .replace(/HH/g, hours)\n    .replace(/mm/g, minutes)\n    .replace(/ss/g, seconds);\n}\n\n/**\n * Format phone number\n * @example formatPhoneNumber('0123456789') // '0123 456 789'\n */\nexport function formatPhoneNumber(phone: string): string {\n  const cleaned = phone.replace(/\\D/g, '');\n\n  if (cleaned.length === 10) {\n    return `${cleaned.slice(0, 4)} ${cleaned.slice(4, 7)} ${cleaned.slice(7)}`;\n  }\n\n  if (cleaned.length === 11) {\n    return `${cleaned.slice(0, 4)} ${cleaned.slice(4, 7)} ${cleaned.slice(7)}`;\n  }\n\n  return phone;\n}\n\n/**\n * Format file size in bytes to human readable format\n * @example formatFileSize(1024) // '1 KB'\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];\n}\n\n/**\n * Truncate text with ellipsis\n * @example truncate('Hello World', 5) // 'Hello...'\n */\nexport function truncate(text: string, maxLength: number, suffix: string = '...'): string {\n  if (text.length <= maxLength) return text;\n  return text.slice(0, maxLength) + suffix;\n}\n",
        "type": "registry:lib"
      }
    ]
  },
  {
    "name": "lib/string",
    "type": "registry:lib",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/string.ts",
        "content": "/**\n * Convert text to URL-friendly slug\n * @example slugify('Hello World!') // 'hello-world'\n */\nexport function slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/[\\s_-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}\n\n/**\n * Convert text to camelCase\n * @example camelCase('hello world') // 'helloWorld'\n */\nexport function camelCase(text: string): string {\n  return text\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, '');\n}\n\n/**\n * Convert text to kebab-case\n * @example kebabCase('Hello World') // 'hello-world'\n */\nexport function kebabCase(text: string): string {\n  return text\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/[\\s_]+/g, '-')\n    .toLowerCase();\n}\n\n/**\n * Capitalize first letter of text\n * @example capitalize('hello') // 'Hello'\n */\nexport function capitalize(text: string): string {\n  if (!text) return text;\n  return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();\n}\n",
        "type": "registry:lib"
      }
    ]
  },
  {
    "name": "lib/toast",
    "type": "registry:lib",
    "dependencies": [
      "sonner"
    ],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/toast.ts",
        "content": "import { toast as sonnerToast } from 'sonner';\n\ntype ToastOptions = {\n  description?: string;\n  duration?: number;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n};\n\n/**\n * Toast utility functions for displaying notifications\n */\nexport const toast = {\n  /**\n   * Show a success toast\n   */\n  success: (message: string, options?: ToastOptions) => {\n    return sonnerToast.success(message, {\n      description: options?.description,\n      duration: options?.duration,\n      action: options?.action,\n    });\n  },\n\n  /**\n   * Show an error toast\n   */\n  error: (message: string, options?: ToastOptions) => {\n    return sonnerToast.error(message, {\n      description: options?.description,\n      duration: options?.duration,\n      action: options?.action,\n    });\n  },\n\n  /**\n   * Show a warning toast\n   */\n  warning: (message: string, options?: ToastOptions) => {\n    return sonnerToast.warning(message, {\n      description: options?.description,\n      duration: options?.duration,\n      action: options?.action,\n    });\n  },\n\n  /**\n   * Show an info toast\n   */\n  info: (message: string, options?: ToastOptions) => {\n    return sonnerToast.info(message, {\n      description: options?.description,\n      duration: options?.duration,\n      action: options?.action,\n    });\n  },\n\n  /**\n   * Show a default toast\n   */\n  default: (message: string, options?: ToastOptions) => {\n    return sonnerToast(message, {\n      description: options?.description,\n      duration: options?.duration,\n      action: options?.action,\n    });\n  },\n\n  /**\n   * Show a loading toast\n   */\n  loading: (message: string, options?: Omit<ToastOptions, 'action'>) => {\n    return sonnerToast.loading(message, {\n      description: options?.description,\n      duration: options?.duration,\n    });\n  },\n\n  /**\n   * Show a promise toast (loading -> success/error)\n   */\n  promise: <T>(\n    promise: Promise<T>,\n    messages: {\n      loading: string;\n      success: string | ((data: T) => string);\n      error: string | ((error: unknown) => string);\n    },\n    options?: Omit<ToastOptions, 'title' | 'description'>,\n  ) => {\n    return sonnerToast.promise(promise, {\n      loading: messages.loading,\n      success: messages.success,\n      error: messages.error,\n      duration: options?.duration,\n    });\n  },\n\n  /**\n   * Dismiss a toast by ID\n   */\n  dismiss: (toastId?: string | number) => {\n    sonnerToast.dismiss(toastId);\n  },\n\n  /**\n   * Dismiss all toasts\n   */\n  dismissAll: () => {\n    sonnerToast.dismiss();\n  },\n};\n",
        "type": "registry:lib"
      }
    ]
  },
  {
    "name": "lib/types",
    "type": "registry:lib",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/types.ts",
        "content": "/**\n * Make all properties in T optional recursively\n */\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\n/**\n * Make specific fields required\n */\nexport type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\n/**\n * Make specific fields optional\n */\nexport type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/**\n * Prettify type for better IntelliSense\n */\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n",
        "type": "registry:lib"
      }
    ]
  },
  {
    "name": "lib/utils",
    "type": "registry:lib",
    "dependencies": [
      "clsx",
      "tailwind-merge"
    ],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/utils.ts",
        "content": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Get nested object property by path string\n * @example get({ user: { name: 'John' } }, 'user.name') // 'John'\n */\nexport function get<T = unknown>(obj: unknown, path: string): T | undefined {\n  const keys = path.split('.');\n  let result: unknown = obj;\n\n  for (const key of keys) {\n    if (result === null || result === undefined || typeof result !== 'object') {\n      return undefined;\n    }\n    result = (result as Record<string, unknown>)[key];\n  }\n\n  return result as T;\n}\n\n/**\n * Check if value exists (not null, undefined, or empty string)\n */\nexport function hasValue(value: unknown): boolean {\n  if (value === null || value === undefined) {\n    return false;\n  }\n  if (typeof value === 'string' && value.trim() === '') {\n    return false;\n  }\n  return true;\n}\n",
        "type": "registry:lib"
      }
    ]
  },
  {
    "name": "lib/validate",
    "type": "registry:lib",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "lib/validate.ts",
        "content": "import { REGEX } from '../constants/regex';\n\n/**\n * Validate email address\n * @example validateEmail('test@example.com') // true\n */\nexport function validateEmail(email: string): boolean {\n  return REGEX.email.test(email);\n}\n\n/**\n * Validate phone number (10-11 digits)\n * @example validatePhone('0123456789') // true\n */\nexport function validatePhone(phone: string): boolean {\n  return REGEX.phone.test(phone);\n}\n\n/**\n * Validate Vietnamese phone number\n * @example validateVietnamesePhone('0912345678') // true\n */\nexport function validateVietnamesePhone(phone: string): boolean {\n  return REGEX.vietnamesePhone.test(phone);\n}\n\n/**\n * Validate URL\n * @example validateURL('https://example.com') // true\n */\nexport function validateURL(url: string): boolean {\n  return REGEX.url.test(url);\n}\n",
        "type": "registry:lib"
      }
    ]
  }
]