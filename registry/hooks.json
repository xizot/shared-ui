[
  {
    "name": "hooks/use-aria-label",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-aria-label.ts",
        "content": "import * as React from 'react';\n\ninterface UseAriaLabelOptions {\n  label?: string;\n  labelledBy?: string;\n  describedBy?: string;\n}\n\nexport function useAriaLabel(options: UseAriaLabelOptions = {}) {\n  const { label, labelledBy, describedBy } = options;\n\n  return React.useMemo(\n    () => ({\n      'aria-label': label,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n    }),\n    [label, labelledBy, describedBy],\n  );\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-breakpoint",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-breakpoint.ts",
        "content": "import { useMediaQuery } from './use-media-query';\nimport { BREAKPOINTS, type Breakpoint } from '../constants/breakpoints';\n\nexport function useBreakpoint(): Breakpoint | null {\n  const is2xl = useMediaQuery(`(min-width: ${BREAKPOINTS['2xl']}px)`);\n  const isXl = useMediaQuery(`(min-width: ${BREAKPOINTS.xl}px)`);\n  const isLg = useMediaQuery(`(min-width: ${BREAKPOINTS.lg}px)`);\n  const isMd = useMediaQuery(`(min-width: ${BREAKPOINTS.md}px)`);\n  const isSm = useMediaQuery(`(min-width: ${BREAKPOINTS.sm}px)`);\n\n  if (is2xl) return '2xl';\n  if (isXl) return 'xl';\n  if (isLg) return 'lg';\n  if (isMd) return 'md';\n  if (isSm) return 'sm';\n  return null;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-click-outside",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-click-outside.ts",
        "content": "import * as React from 'react';\nimport type { RefObject } from 'react';\n\nexport function useClickOutside<T extends HTMLElement = HTMLElement>(\n  ref: RefObject<T>,\n  handler: (event: MouseEvent | TouchEvent) => void,\n): void {\n  React.useEffect(() => {\n    const listener = (event: MouseEvent | TouchEvent) => {\n      const el = ref?.current;\n      if (!el || el.contains(event.target as Node)) {\n        return;\n      }\n\n      handler(event);\n    };\n\n    document.addEventListener('mousedown', listener);\n    document.addEventListener('touchstart', listener);\n\n    return () => {\n      document.removeEventListener('mousedown', listener);\n      document.removeEventListener('touchstart', listener);\n    };\n  }, [ref, handler]);\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-copy-to-clipboard",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-copy-to-clipboard.ts",
        "content": "import * as React from 'react';\n\nexport interface UseCopyToClipboardReturn {\n  copy: (text: string) => Promise<boolean>;\n  copied: boolean;\n  error: Error | null;\n}\n\nexport function useCopyToClipboard(): UseCopyToClipboardReturn {\n  const [copied, setCopied] = React.useState(false);\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const copy = React.useCallback(async (text: string): Promise<boolean> => {\n    if (!navigator?.clipboard) {\n      setError(new Error('Clipboard API not available'));\n      return false;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopied(true);\n      setError(null);\n\n      setTimeout(() => {\n        setCopied(false);\n      }, 2000);\n\n      return true;\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to copy'));\n      setCopied(false);\n      return false;\n    }\n  }, []);\n\n  return { copy, copied, error };\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-debounce",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-debounce.ts",
        "content": "import * as React from 'react';\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = React.useState<T>(value);\n\n  React.useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-debounced-callback",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-debounced-callback.ts",
        "content": "import * as React from 'react';\nimport { useRef, useCallback } from 'react';\n\nexport function useDebouncedCallback<T extends (...args: unknown[]) => unknown>(\n  callback: T,\n  delay: number,\n): T {\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n\n  const debouncedCallback = useCallback(\n    (...args: Parameters<T>) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        callback(...args);\n      }, delay);\n    },\n    [callback, delay],\n  ) as T;\n\n  React.useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-focus-trap",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-focus-trap.ts",
        "content": "import * as React from 'react';\nimport type { RefObject } from 'react';\n\nexport function useFocusTrap<T extends HTMLElement = HTMLElement>(\n  ref: RefObject<T>,\n  enabled: boolean = true,\n): void {\n  React.useEffect(() => {\n    if (!enabled || !ref.current) return;\n\n    const element = ref.current;\n    const focusableElements = element.querySelectorAll<HTMLElement>(\n      'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex=\"-1\"])',\n    );\n\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    const handleTabKey = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab') return;\n\n      if (e.shiftKey) {\n        if (document.activeElement === firstElement) {\n          e.preventDefault();\n          lastElement?.focus();\n        }\n      } else {\n        if (document.activeElement === lastElement) {\n          e.preventDefault();\n          firstElement?.focus();\n        }\n      }\n    };\n\n    element.addEventListener('keydown', handleTabKey);\n\n    // Focus first element\n    firstElement?.focus();\n\n    return () => {\n      element.removeEventListener('keydown', handleTabKey);\n    };\n  }, [enabled, ref]);\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-is-tablet",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-is-tablet.ts",
        "content": "import { useMediaQuery } from './use-media-query';\nimport { BREAKPOINTS } from '../constants/breakpoints';\n\nexport function useIsTablet(): boolean {\n  return useMediaQuery(`(min-width: ${BREAKPOINTS.md}px) and (max-width: ${BREAKPOINTS.lg - 1}px)`);\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-keyboard-navigation",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-keyboard-navigation.ts",
        "content": "import * as React from 'react';\n\ntype NavigationDirection = 'horizontal' | 'vertical' | 'both';\n\ninterface UseKeyboardNavigationOptions {\n  direction?: NavigationDirection;\n  loop?: boolean;\n  onNavigate?: (index: number) => void;\n}\n\nexport function useKeyboardNavigation(\n  itemCount: number,\n  options: UseKeyboardNavigationOptions = {},\n): {\n  currentIndex: number;\n  setCurrentIndex: React.Dispatch<React.SetStateAction<number>>;\n  handleKeyDown: (e: React.KeyboardEvent) => void;\n} {\n  const { direction = 'both', loop = false, onNavigate } = options;\n  const [currentIndex, setCurrentIndex] = React.useState(0);\n\n  const handleKeyDown = React.useCallback(\n    (e: React.KeyboardEvent) => {\n      let newIndex = currentIndex;\n\n      if (direction === 'horizontal' || direction === 'both') {\n        if (e.key === 'ArrowLeft') {\n          e.preventDefault();\n          newIndex = currentIndex > 0 ? currentIndex - 1 : loop ? itemCount - 1 : currentIndex;\n        } else if (e.key === 'ArrowRight') {\n          e.preventDefault();\n          newIndex = currentIndex < itemCount - 1 ? currentIndex + 1 : loop ? 0 : currentIndex;\n        }\n      }\n\n      if (direction === 'vertical' || direction === 'both') {\n        if (e.key === 'ArrowUp') {\n          e.preventDefault();\n          newIndex = currentIndex > 0 ? currentIndex - 1 : loop ? itemCount - 1 : currentIndex;\n        } else if (e.key === 'ArrowDown') {\n          e.preventDefault();\n          newIndex = currentIndex < itemCount - 1 ? currentIndex + 1 : loop ? 0 : currentIndex;\n        }\n      }\n\n      if (newIndex !== currentIndex) {\n        setCurrentIndex(newIndex);\n        onNavigate?.(newIndex);\n      }\n    },\n    [currentIndex, itemCount, direction, loop, onNavigate],\n  );\n\n  return { currentIndex, setCurrentIndex, handleKeyDown };\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-local-storage",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-local-storage.ts",
        "content": "import * as React from 'react';\n\ntype SetValue<T> = React.Dispatch<React.SetStateAction<T>>;\n\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, SetValue<T>, () => void] {\n  const [storedValue, setStoredValue] = React.useState<T>(() => {\n    if (typeof window === 'undefined') {\n      return initialValue;\n    }\n\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue: SetValue<T> = React.useCallback(\n    (value) => {\n      try {\n        const valueToStore = value instanceof Function ? value(storedValue) : value;\n        setStoredValue(valueToStore);\n\n        if (typeof window !== 'undefined') {\n          window.localStorage.setItem(key, JSON.stringify(valueToStore));\n        }\n      } catch (error) {\n        console.error(`Error setting localStorage key \"${key}\":`, error);\n      }\n    },\n    [key, storedValue],\n  );\n\n  const removeValue = React.useCallback(() => {\n    try {\n      setStoredValue(initialValue);\n      if (typeof window !== 'undefined') {\n        window.localStorage.removeItem(key);\n      }\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  return [storedValue, setValue, removeValue];\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-media-query",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-media-query.ts",
        "content": "import * as React from 'react';\n\nexport function useMediaQuery(query: string): boolean {\n  const [matches, setMatches] = React.useState<boolean>(() => {\n    if (typeof window === 'undefined') return false;\n    return window.matchMedia(query).matches;\n  });\n\n  React.useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const mediaQuery = window.matchMedia(query);\n    const handler = (event: MediaQueryListEvent) => {\n      setMatches(event.matches);\n    };\n\n    // Modern browsers\n    if (mediaQuery.addEventListener) {\n      mediaQuery.addEventListener('change', handler);\n      return () => mediaQuery.removeEventListener('change', handler);\n    } else {\n      // Fallback for older browsers\n      mediaQuery.addListener(handler);\n      return () => mediaQuery.removeListener(handler);\n    }\n  }, [query]);\n\n  return matches;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-memoized-callback",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-memoized-callback.ts",
        "content": "import type { DependencyList } from 'react';\nimport * as React from 'react';\n\nexport function useMemoizedCallback<T extends (...args: unknown[]) => unknown>(\n  callback: T,\n  deps: DependencyList,\n): T {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(callback, deps) as T;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-mobile",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-mobile.ts",
        "content": "import * as React from 'react';\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener('change', onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener('change', onChange);\n  }, []);\n\n  return !!isMobile;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-previous",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-previous.ts",
        "content": "import * as React from 'react';\n\nexport function usePrevious<T>(value: T): T | undefined {\n  const [previous, setPrevious] = React.useState<T | undefined>(undefined);\n  const currentRef = React.useRef<T>(value);\n\n  React.useEffect(() => {\n    if (currentRef.current !== value) {\n      setPrevious(currentRef.current);\n      currentRef.current = value;\n    }\n  }, [value]);\n\n  return previous;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-session-storage",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-session-storage.ts",
        "content": "import * as React from 'react';\n\ntype SetValue<T> = React.Dispatch<React.SetStateAction<T>>;\n\nexport function useSessionStorage<T>(key: string, initialValue: T): [T, SetValue<T>, () => void] {\n  const [storedValue, setStoredValue] = React.useState<T>(() => {\n    if (typeof window === 'undefined') {\n      return initialValue;\n    }\n\n    try {\n      const item = window.sessionStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading sessionStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue: SetValue<T> = React.useCallback(\n    (value) => {\n      try {\n        const valueToStore = value instanceof Function ? value(storedValue) : value;\n        setStoredValue(valueToStore);\n\n        if (typeof window !== 'undefined') {\n          window.sessionStorage.setItem(key, JSON.stringify(valueToStore));\n        }\n      } catch (error) {\n        console.error(`Error setting sessionStorage key \"${key}\":`, error);\n      }\n    },\n    [key, storedValue],\n  );\n\n  const removeValue = React.useCallback(() => {\n    try {\n      setStoredValue(initialValue);\n      if (typeof window !== 'undefined') {\n        window.sessionStorage.removeItem(key);\n      }\n    } catch (error) {\n      console.error(`Error removing sessionStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  return [storedValue, setValue, removeValue];\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-throttle",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-throttle.ts",
        "content": "import * as React from 'react';\n\nexport function useThrottle<T>(value: T, delay: number): T {\n  const [throttledValue, setThrottledValue] = React.useState<T>(value);\n  const lastRan = React.useRef<number | undefined>(undefined);\n  \n  React.useEffect(() => {\n    if (lastRan.current === undefined) {\n      lastRan.current = Date.now();\n    }\n  }, []);\n\n  React.useEffect(() => {\n    if (lastRan.current === undefined) {\n      return;\n    }\n    \n    const handler = setTimeout(\n      () => {\n        const now = Date.now();\n        if (lastRan.current !== undefined && now - lastRan.current >= delay) {\n          setThrottledValue(value);\n          lastRan.current = now;\n        }\n      },\n      lastRan.current !== undefined ? delay - (Date.now() - lastRan.current) : delay,\n    );\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return throttledValue;\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-toggle",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-toggle.ts",
        "content": "import * as React from 'react';\n\nexport function useToggle(\n  initialValue: boolean = false,\n): [boolean, () => void, React.Dispatch<React.SetStateAction<boolean>>] {\n  const [value, setValue] = React.useState(initialValue);\n\n  const toggle = React.useCallback(() => {\n    setValue((prev) => !prev);\n  }, []);\n\n  return [value, toggle, setValue];\n}\n",
        "type": "registry:hook"
      }
    ]
  },
  {
    "name": "hooks/use-window-size",
    "type": "registry:hook",
    "dependencies": [],
    "registryDependencies": [],
    "files": [
      {
        "path": "hooks/use-window-size.ts",
        "content": "import * as React from 'react';\n\nexport interface WindowSize {\n  width: number;\n  height: number;\n}\n\nexport function useWindowSize(): WindowSize {\n  const [windowSize, setWindowSize] = React.useState<WindowSize>(() => {\n    if (typeof window === 'undefined') {\n      return { width: 0, height: 0 };\n    }\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n  });\n\n  React.useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n}\n",
        "type": "registry:hook"
      }
    ]
  }
]